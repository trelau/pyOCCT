/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Standard.hxx>
#include <BRepApprox_TheMultiLineOfApprox.hxx>
#include <Standard_TypeDef.hxx>
#include <Approx_ParametrizationType.hxx>
#include <math_Vector.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <TColStd_Array1OfInteger.hxx>
#include <AppParCurves_Constraint.hxx>
#include <AppParCurves_MultiBSpCurve.hxx>
#include <AppParCurves_MultiCurve.hxx>
#include <Standard_Handle.hxx>
#include <TColStd_HArray1OfReal.hxx>
#include <TColStd_HArray1OfInteger.hxx>
#include <AppParCurves_HArray1OfConstraintCouple.hxx>
#include <BRepApprox_TheComputeLineOfApprox.hxx>
#include <AppParCurves_SequenceOfMultiCurve.hxx>
#include <Approx_SequenceOfHArray1OfReal.hxx>
#include <TColStd_SequenceOfReal.hxx>
#include <BRepApprox_TheComputeLineBezierOfApprox.hxx>
#include <BRepAdaptor_Surface.hxx>
#include <BRepApprox_ApproxLine.hxx>
#include <IntSurf_Quadric.hxx>
#include <Approx_MCurvesToBSpCurve.hxx>
#include <BRepApprox_Approx.hxx>
#include <NCollection_Vector.hxx>
#include <Standard_Transient.hxx>
#include <Geom_BSplineCurve.hxx>
#include <Geom2d_BSplineCurve.hxx>
#include <IntSurf_LineOn2S.hxx>
#include <IntSurf_PntOn2S.hxx>
#include <Standard_Std.hxx>
#include <Standard_Type.hxx>
#include <math_BFGS.hxx>
#include <math_MultipleVarFunctionWithGradient.hxx>
#include <BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox.hxx>
#include <Approx_Status.hxx>
#include <TColgp_Array1OfPnt.hxx>
#include <TColgp_Array1OfPnt2d.hxx>
#include <TColgp_Array1OfVec.hxx>
#include <TColgp_Array1OfVec2d.hxx>
#include <math_Matrix.hxx>
#include <math_IntegerVector.hxx>
#include <BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.hxx>
#include <BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.hxx>
#include <BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox.hxx>
#include <BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox.hxx>
#include <BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.hxx>
#include <BRepApprox_MyGradientbisOfTheComputeLineOfApprox.hxx>
#include <BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.hxx>
#include <BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.hxx>
#include <BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.hxx>
#include <BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.hxx>
#include <BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.hxx>
#include <BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.hxx>
#include <BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.hxx>
#include <GeomAbs_Shape.hxx>
#include <Adaptor3d_HSurface.hxx>
#include <gp_Pnt.hxx>
#include <gp_Vec.hxx>
#include <GeomAbs_SurfaceType.hxx>
#include <gp_Pln.hxx>
#include <gp_Cylinder.hxx>
#include <gp_Cone.hxx>
#include <gp_Torus.hxx>
#include <gp_Sphere.hxx>
#include <Geom_BezierSurface.hxx>
#include <Geom_BSplineSurface.hxx>
#include <gp_Ax1.hxx>
#include <gp_Dir.hxx>
#include <Adaptor3d_HCurve.hxx>
#include <BRepApprox_SurfaceTool.hxx>
#include <math_FunctionSetWithDerivatives.hxx>
#include <IntImp_ConstIsoparametric.hxx>
#include <gp_Dir2d.hxx>
#include <BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.hxx>
#include <BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.hxx>
#include <ApproxInt_SvSurfaces.hxx>
#include <gp_Vec2d.hxx>
#include <gp_Pnt2d.hxx>
#include <BRepApprox_TheImpPrmSvSurfacesOfApprox.hxx>
#include <math_FunctionSetRoot.hxx>
#include <BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.hxx>
#include <BRepApprox_TheMultiLineToolOfApprox.hxx>
#include <BRepApprox_ThePrmPrmSvSurfacesOfApprox.hxx>

PYBIND11_MODULE(BRepApprox, mod) {

py::module::import("OCCT.Standard");
py::module::import("OCCT.Approx");
py::module::import("OCCT.math");
py::module::import("OCCT.TColStd");
py::module::import("OCCT.AppParCurves");
py::module::import("OCCT.BRepAdaptor");
py::module::import("OCCT.IntSurf");
py::module::import("OCCT.NCollection");
py::module::import("OCCT.Geom");
py::module::import("OCCT.Geom2d");
py::module::import("OCCT.TColgp");
py::module::import("OCCT.GeomAbs");
py::module::import("OCCT.Adaptor3d");
py::module::import("OCCT.gp");
py::module::import("OCCT.IntImp");
py::module::import("OCCT.ApproxInt");

// CLASS: BREPAPPROX_THECOMPUTELINEOFAPPROX
py::class_<BRepApprox_TheComputeLineOfApprox> cls_BRepApprox_TheComputeLineOfApprox(mod, "BRepApprox_TheComputeLineOfApprox", "None");

// Constructors
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &>(), py::arg("Line"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &>(), py::arg("Line"), py::arg("Parameters"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("Squares"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const math_Vector &>(), py::arg("Parameters"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const math_Vector &, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("Squares"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<>());
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const Standard_Integer>(), py::arg("degreemin"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("degreemin"), py::arg("degreemax"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"));
cls_BRepApprox_TheComputeLineOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));

// Methods
// cls_BRepApprox_TheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_TheComputeLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_TheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_TheComputeLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_TheComputeLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_TheComputeLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_TheComputeLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_TheComputeLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_TheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_TheComputeLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_TheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_TheComputeLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_TheComputeLineOfApprox.def("Interpol", (void (BRepApprox_TheComputeLineOfApprox::*)(const BRepApprox_TheMultiLineOfApprox &)) &BRepApprox_TheComputeLineOfApprox::Interpol, "Constructs an interpolation of the MultiLine <Line> The result will be a C2 curve of degree 3.", py::arg("Line"));
cls_BRepApprox_TheComputeLineOfApprox.def("Init", [](BRepApprox_TheComputeLineOfApprox &self) -> void { return self.Init(); });
cls_BRepApprox_TheComputeLineOfApprox.def("Init", [](BRepApprox_TheComputeLineOfApprox &self, const Standard_Integer a0) -> void { return self.Init(a0); });
cls_BRepApprox_TheComputeLineOfApprox.def("Init", [](BRepApprox_TheComputeLineOfApprox &self, const Standard_Integer a0, const Standard_Integer a1) -> void { return self.Init(a0, a1); });
cls_BRepApprox_TheComputeLineOfApprox.def("Init", [](BRepApprox_TheComputeLineOfApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2) -> void { return self.Init(a0, a1, a2); });
cls_BRepApprox_TheComputeLineOfApprox.def("Init", [](BRepApprox_TheComputeLineOfApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3) -> void { return self.Init(a0, a1, a2, a3); });
cls_BRepApprox_TheComputeLineOfApprox.def("Init", [](BRepApprox_TheComputeLineOfApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4) -> void { return self.Init(a0, a1, a2, a3, a4); });
cls_BRepApprox_TheComputeLineOfApprox.def("Init", [](BRepApprox_TheComputeLineOfApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4, const Standard_Boolean a5) -> void { return self.Init(a0, a1, a2, a3, a4, a5); });
cls_BRepApprox_TheComputeLineOfApprox.def("Init", [](BRepApprox_TheComputeLineOfApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4, const Standard_Boolean a5, const Approx_ParametrizationType a6) -> void { return self.Init(a0, a1, a2, a3, a4, a5, a6); });
cls_BRepApprox_TheComputeLineOfApprox.def("Init", (void (BRepApprox_TheComputeLineOfApprox::*)(const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean)) &BRepApprox_TheComputeLineOfApprox::Init, "Initializes the fields of the algorithm.", py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));
cls_BRepApprox_TheComputeLineOfApprox.def("Perform", (void (BRepApprox_TheComputeLineOfApprox::*)(const BRepApprox_TheMultiLineOfApprox &)) &BRepApprox_TheComputeLineOfApprox::Perform, "runs the algorithm after having initialized the fields.", py::arg("Line"));
cls_BRepApprox_TheComputeLineOfApprox.def("SetParameters", (void (BRepApprox_TheComputeLineOfApprox::*)(const math_Vector &)) &BRepApprox_TheComputeLineOfApprox::SetParameters, "The approximation will begin with the set of parameters <ThePar>.", py::arg("ThePar"));
cls_BRepApprox_TheComputeLineOfApprox.def("SetKnots", (void (BRepApprox_TheComputeLineOfApprox::*)(const TColStd_Array1OfReal &)) &BRepApprox_TheComputeLineOfApprox::SetKnots, "The approximation will be done with the set of knots <Knots>. The multiplicities will be set with the degree and the desired continuity.", py::arg("Knots"));
cls_BRepApprox_TheComputeLineOfApprox.def("SetKnotsAndMultiplicities", (void (BRepApprox_TheComputeLineOfApprox::*)(const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &)) &BRepApprox_TheComputeLineOfApprox::SetKnotsAndMultiplicities, "The approximation will be done with the set of knots <Knots> and the multiplicities <Mults>.", py::arg("Knots"), py::arg("Mults"));
cls_BRepApprox_TheComputeLineOfApprox.def("SetDegrees", (void (BRepApprox_TheComputeLineOfApprox::*)(const Standard_Integer, const Standard_Integer)) &BRepApprox_TheComputeLineOfApprox::SetDegrees, "changes the degrees of the approximation.", py::arg("degreemin"), py::arg("degreemax"));
cls_BRepApprox_TheComputeLineOfApprox.def("SetTolerances", (void (BRepApprox_TheComputeLineOfApprox::*)(const Standard_Real, const Standard_Real)) &BRepApprox_TheComputeLineOfApprox::SetTolerances, "Changes the tolerances of the approximation.", py::arg("Tolerance3d"), py::arg("Tolerance2d"));
cls_BRepApprox_TheComputeLineOfApprox.def("SetContinuity", (void (BRepApprox_TheComputeLineOfApprox::*)(const Standard_Integer)) &BRepApprox_TheComputeLineOfApprox::SetContinuity, "sets the continuity of the spline. if C = 2, the spline will be C2.", py::arg("C"));
cls_BRepApprox_TheComputeLineOfApprox.def("SetConstraints", (void (BRepApprox_TheComputeLineOfApprox::*)(const AppParCurves_Constraint, const AppParCurves_Constraint)) &BRepApprox_TheComputeLineOfApprox::SetConstraints, "changes the first and the last constraint points.", py::arg("firstC"), py::arg("lastC"));
cls_BRepApprox_TheComputeLineOfApprox.def("SetPeriodic", (void (BRepApprox_TheComputeLineOfApprox::*)(const Standard_Boolean)) &BRepApprox_TheComputeLineOfApprox::SetPeriodic, "Sets periodic flag. If thePeriodic = Standard_True, algorith tries to build periodic multicurve using corresponding C1 boundary condition for first and last multipoints. Multiline must be closed.", py::arg("thePeriodic"));
cls_BRepApprox_TheComputeLineOfApprox.def("IsAllApproximated", (Standard_Boolean (BRepApprox_TheComputeLineOfApprox::*)() const) &BRepApprox_TheComputeLineOfApprox::IsAllApproximated, "returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.");
cls_BRepApprox_TheComputeLineOfApprox.def("IsToleranceReached", (Standard_Boolean (BRepApprox_TheComputeLineOfApprox::*)() const) &BRepApprox_TheComputeLineOfApprox::IsToleranceReached, "returns False if the status NoPointsAdded has been sent.");
cls_BRepApprox_TheComputeLineOfApprox.def("Error", [](BRepApprox_TheComputeLineOfApprox &self, Standard_Real & tol3d, Standard_Real & tol2d){ self.Error(tol3d, tol2d); return std::tuple<Standard_Real &, Standard_Real &>(tol3d, tol2d); }, "returns the tolerances 2d and 3d of the MultiBSpCurve.", py::arg("tol3d"), py::arg("tol2d"));
cls_BRepApprox_TheComputeLineOfApprox.def("Value", (const AppParCurves_MultiBSpCurve & (BRepApprox_TheComputeLineOfApprox::*)() const) &BRepApprox_TheComputeLineOfApprox::Value, "returns the result of the approximation.");
cls_BRepApprox_TheComputeLineOfApprox.def("ChangeValue", (AppParCurves_MultiBSpCurve & (BRepApprox_TheComputeLineOfApprox::*)()) &BRepApprox_TheComputeLineOfApprox::ChangeValue, "returns the result of the approximation.");
cls_BRepApprox_TheComputeLineOfApprox.def("Parameters", (const TColStd_Array1OfReal & (BRepApprox_TheComputeLineOfApprox::*)() const) &BRepApprox_TheComputeLineOfApprox::Parameters, "returns the new parameters of the approximation corresponding to the points of the MultiBSpCurve.");

// CLASS: BREPAPPROX_THECOMPUTELINEBEZIEROFAPPROX
py::class_<BRepApprox_TheComputeLineBezierOfApprox> cls_BRepApprox_TheComputeLineBezierOfApprox(mod, "BRepApprox_TheComputeLineBezierOfApprox", "None");

// Constructors
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &>(), py::arg("Line"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &>(), py::arg("Line"), py::arg("Parameters"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("Squares"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const math_Vector &>(), py::arg("Parameters"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const math_Vector &, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("Squares"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<>());
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const Standard_Integer>(), py::arg("degreemin"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("degreemin"), py::arg("degreemax"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));

// Methods
// cls_BRepApprox_TheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_TheComputeLineBezierOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_TheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_TheComputeLineBezierOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_TheComputeLineBezierOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_TheComputeLineBezierOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_TheComputeLineBezierOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_TheComputeLineBezierOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_TheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_TheComputeLineBezierOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_TheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_TheComputeLineBezierOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Init", [](BRepApprox_TheComputeLineBezierOfApprox &self) -> void { return self.Init(); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Init", [](BRepApprox_TheComputeLineBezierOfApprox &self, const Standard_Integer a0) -> void { return self.Init(a0); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Init", [](BRepApprox_TheComputeLineBezierOfApprox &self, const Standard_Integer a0, const Standard_Integer a1) -> void { return self.Init(a0, a1); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Init", [](BRepApprox_TheComputeLineBezierOfApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2) -> void { return self.Init(a0, a1, a2); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Init", [](BRepApprox_TheComputeLineBezierOfApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3) -> void { return self.Init(a0, a1, a2, a3); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Init", [](BRepApprox_TheComputeLineBezierOfApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4) -> void { return self.Init(a0, a1, a2, a3, a4); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Init", [](BRepApprox_TheComputeLineBezierOfApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4, const Standard_Boolean a5) -> void { return self.Init(a0, a1, a2, a3, a4, a5); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Init", [](BRepApprox_TheComputeLineBezierOfApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4, const Standard_Boolean a5, const Approx_ParametrizationType a6) -> void { return self.Init(a0, a1, a2, a3, a4, a5, a6); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Init", (void (BRepApprox_TheComputeLineBezierOfApprox::*)(const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean)) &BRepApprox_TheComputeLineBezierOfApprox::Init, "Initializes the fields of the algorithm.", py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Perform", (void (BRepApprox_TheComputeLineBezierOfApprox::*)(const BRepApprox_TheMultiLineOfApprox &)) &BRepApprox_TheComputeLineBezierOfApprox::Perform, "runs the algorithm after having initialized the fields.", py::arg("Line"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def("SetDegrees", (void (BRepApprox_TheComputeLineBezierOfApprox::*)(const Standard_Integer, const Standard_Integer)) &BRepApprox_TheComputeLineBezierOfApprox::SetDegrees, "changes the degrees of the approximation.", py::arg("degreemin"), py::arg("degreemax"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def("SetTolerances", (void (BRepApprox_TheComputeLineBezierOfApprox::*)(const Standard_Real, const Standard_Real)) &BRepApprox_TheComputeLineBezierOfApprox::SetTolerances, "Changes the tolerances of the approximation.", py::arg("Tolerance3d"), py::arg("Tolerance2d"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def("SetConstraints", (void (BRepApprox_TheComputeLineBezierOfApprox::*)(const AppParCurves_Constraint, const AppParCurves_Constraint)) &BRepApprox_TheComputeLineBezierOfApprox::SetConstraints, "changes the first and the last constraint points.", py::arg("firstC"), py::arg("lastC"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def("IsAllApproximated", (Standard_Boolean (BRepApprox_TheComputeLineBezierOfApprox::*)() const) &BRepApprox_TheComputeLineBezierOfApprox::IsAllApproximated, "returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.");
cls_BRepApprox_TheComputeLineBezierOfApprox.def("IsToleranceReached", (Standard_Boolean (BRepApprox_TheComputeLineBezierOfApprox::*)() const) &BRepApprox_TheComputeLineBezierOfApprox::IsToleranceReached, "returns False if the status NoPointsAdded has been sent.");
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Error", [](BRepApprox_TheComputeLineBezierOfApprox &self, const Standard_Integer Index, Standard_Real & tol3d, Standard_Real & tol2d){ self.Error(Index, tol3d, tol2d); return std::tuple<Standard_Real &, Standard_Real &>(tol3d, tol2d); }, "returns the tolerances 2d and 3d of the <Index> MultiCurve.", py::arg("Index"), py::arg("tol3d"), py::arg("tol2d"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def("NbMultiCurves", (Standard_Integer (BRepApprox_TheComputeLineBezierOfApprox::*)() const) &BRepApprox_TheComputeLineBezierOfApprox::NbMultiCurves, "Returns the number of MultiCurve doing the approximation of the MultiLine.");
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Value", [](BRepApprox_TheComputeLineBezierOfApprox &self) -> const AppParCurves_MultiCurve & { return self.Value(); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Value", (const AppParCurves_MultiCurve & (BRepApprox_TheComputeLineBezierOfApprox::*)(const Standard_Integer) const) &BRepApprox_TheComputeLineBezierOfApprox::Value, "returns the result of the approximation.", py::arg("Index"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def("ChangeValue", [](BRepApprox_TheComputeLineBezierOfApprox &self) -> AppParCurves_MultiCurve & { return self.ChangeValue(); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("ChangeValue", (AppParCurves_MultiCurve & (BRepApprox_TheComputeLineBezierOfApprox::*)(const Standard_Integer)) &BRepApprox_TheComputeLineBezierOfApprox::ChangeValue, "returns the result of the approximation.", py::arg("Index"));
cls_BRepApprox_TheComputeLineBezierOfApprox.def("SplineValue", (const AppParCurves_MultiBSpCurve & (BRepApprox_TheComputeLineBezierOfApprox::*)()) &BRepApprox_TheComputeLineBezierOfApprox::SplineValue, "returns the result of the approximation.");
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Parametrization", (Approx_ParametrizationType (BRepApprox_TheComputeLineBezierOfApprox::*)() const) &BRepApprox_TheComputeLineBezierOfApprox::Parametrization, "returns the type of parametrization");
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Parameters", [](BRepApprox_TheComputeLineBezierOfApprox &self) -> const TColStd_Array1OfReal & { return self.Parameters(); });
cls_BRepApprox_TheComputeLineBezierOfApprox.def("Parameters", (const TColStd_Array1OfReal & (BRepApprox_TheComputeLineBezierOfApprox::*)(const Standard_Integer) const) &BRepApprox_TheComputeLineBezierOfApprox::Parameters, "returns the new parameters of the approximation corresponding to the points of the multicurve <Index>.", py::arg("Index"));

// CLASS: BREPAPPROX_APPROX
py::class_<BRepApprox_Approx> cls_BRepApprox_Approx(mod, "BRepApprox_Approx", "None");

// Constructors
cls_BRepApprox_Approx.def(py::init<>());

// Methods
// cls_BRepApprox_Approx.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_Approx::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_Approx.def_static("operator delete_", (void (*)(void *)) &BRepApprox_Approx::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_Approx.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_Approx::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_Approx.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_Approx::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_Approx.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_Approx::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_Approx.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_Approx::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_Approx.def("Perform", [](BRepApprox_Approx &self, const BRepAdaptor_Surface & a0, const BRepAdaptor_Surface & a1, const opencascade::handle<BRepApprox_ApproxLine> & a2) -> void { return self.Perform(a0, a1, a2); });
cls_BRepApprox_Approx.def("Perform", [](BRepApprox_Approx &self, const BRepAdaptor_Surface & a0, const BRepAdaptor_Surface & a1, const opencascade::handle<BRepApprox_ApproxLine> & a2, const Standard_Boolean a3) -> void { return self.Perform(a0, a1, a2, a3); });
cls_BRepApprox_Approx.def("Perform", [](BRepApprox_Approx &self, const BRepAdaptor_Surface & a0, const BRepAdaptor_Surface & a1, const opencascade::handle<BRepApprox_ApproxLine> & a2, const Standard_Boolean a3, const Standard_Boolean a4) -> void { return self.Perform(a0, a1, a2, a3, a4); });
cls_BRepApprox_Approx.def("Perform", [](BRepApprox_Approx &self, const BRepAdaptor_Surface & a0, const BRepAdaptor_Surface & a1, const opencascade::handle<BRepApprox_ApproxLine> & a2, const Standard_Boolean a3, const Standard_Boolean a4, const Standard_Boolean a5) -> void { return self.Perform(a0, a1, a2, a3, a4, a5); });
cls_BRepApprox_Approx.def("Perform", [](BRepApprox_Approx &self, const BRepAdaptor_Surface & a0, const BRepAdaptor_Surface & a1, const opencascade::handle<BRepApprox_ApproxLine> & a2, const Standard_Boolean a3, const Standard_Boolean a4, const Standard_Boolean a5, const Standard_Integer a6) -> void { return self.Perform(a0, a1, a2, a3, a4, a5, a6); });
cls_BRepApprox_Approx.def("Perform", (void (BRepApprox_Approx::*)(const BRepAdaptor_Surface &, const BRepAdaptor_Surface &, const opencascade::handle<BRepApprox_ApproxLine> &, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Integer, const Standard_Integer)) &BRepApprox_Approx::Perform, "None", py::arg("Surf1"), py::arg("Surf2"), py::arg("aLine"), py::arg("ApproxXYZ"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("indicemin"), py::arg("indicemax"));
cls_BRepApprox_Approx.def("Perform", [](BRepApprox_Approx &self, const opencascade::handle<BRepApprox_ApproxLine> & a0) -> void { return self.Perform(a0); });
cls_BRepApprox_Approx.def("Perform", [](BRepApprox_Approx &self, const opencascade::handle<BRepApprox_ApproxLine> & a0, const Standard_Boolean a1) -> void { return self.Perform(a0, a1); });
cls_BRepApprox_Approx.def("Perform", [](BRepApprox_Approx &self, const opencascade::handle<BRepApprox_ApproxLine> & a0, const Standard_Boolean a1, const Standard_Boolean a2) -> void { return self.Perform(a0, a1, a2); });
cls_BRepApprox_Approx.def("Perform", [](BRepApprox_Approx &self, const opencascade::handle<BRepApprox_ApproxLine> & a0, const Standard_Boolean a1, const Standard_Boolean a2, const Standard_Boolean a3) -> void { return self.Perform(a0, a1, a2, a3); });
cls_BRepApprox_Approx.def("Perform", [](BRepApprox_Approx &self, const opencascade::handle<BRepApprox_ApproxLine> & a0, const Standard_Boolean a1, const Standard_Boolean a2, const Standard_Boolean a3, const Standard_Integer a4) -> void { return self.Perform(a0, a1, a2, a3, a4); });
cls_BRepApprox_Approx.def("Perform", (void (BRepApprox_Approx::*)(const opencascade::handle<BRepApprox_ApproxLine> &, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Integer, const Standard_Integer)) &BRepApprox_Approx::Perform, "None", py::arg("aLine"), py::arg("ApproxXYZ"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("indicemin"), py::arg("indicemax"));
cls_BRepApprox_Approx.def("SetParameters", [](BRepApprox_Approx &self, const Standard_Real a0, const Standard_Real a1, const Standard_Integer a2, const Standard_Integer a3, const Standard_Integer a4) -> void { return self.SetParameters(a0, a1, a2, a3, a4); });
cls_BRepApprox_Approx.def("SetParameters", [](BRepApprox_Approx &self, const Standard_Real a0, const Standard_Real a1, const Standard_Integer a2, const Standard_Integer a3, const Standard_Integer a4, const Standard_Integer a5) -> void { return self.SetParameters(a0, a1, a2, a3, a4, a5); });
cls_BRepApprox_Approx.def("SetParameters", [](BRepApprox_Approx &self, const Standard_Real a0, const Standard_Real a1, const Standard_Integer a2, const Standard_Integer a3, const Standard_Integer a4, const Standard_Integer a5, const Standard_Boolean a6) -> void { return self.SetParameters(a0, a1, a2, a3, a4, a5, a6); });
cls_BRepApprox_Approx.def("SetParameters", (void (BRepApprox_Approx::*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType)) &BRepApprox_Approx::SetParameters, "None", py::arg("Tol3d"), py::arg("Tol2d"), py::arg("DegMin"), py::arg("DegMax"), py::arg("NbIterMax"), py::arg("NbPntMax"), py::arg("ApproxWithTangency"), py::arg("Parametrization"));
// cls_BRepApprox_Approx.def("Perform", (void (BRepApprox_Approx::*)()) &BRepApprox_Approx::Perform, "None");
cls_BRepApprox_Approx.def("TolReached3d", (Standard_Real (BRepApprox_Approx::*)() const) &BRepApprox_Approx::TolReached3d, "None");
cls_BRepApprox_Approx.def("TolReached2d", (Standard_Real (BRepApprox_Approx::*)() const) &BRepApprox_Approx::TolReached2d, "None");
cls_BRepApprox_Approx.def("IsDone", (Standard_Boolean (BRepApprox_Approx::*)() const) &BRepApprox_Approx::IsDone, "None");
cls_BRepApprox_Approx.def("NbMultiCurves", (Standard_Integer (BRepApprox_Approx::*)() const) &BRepApprox_Approx::NbMultiCurves, "None");
cls_BRepApprox_Approx.def("Value", (const AppParCurves_MultiBSpCurve & (BRepApprox_Approx::*)(const Standard_Integer) const) &BRepApprox_Approx::Value, "None", py::arg("Index"));

// CLASS: BREPAPPROX_APPROXLINE
py::class_<BRepApprox_ApproxLine, opencascade::handle<BRepApprox_ApproxLine>, Standard_Transient> cls_BRepApprox_ApproxLine(mod, "BRepApprox_ApproxLine", "None");

// Constructors
cls_BRepApprox_ApproxLine.def(py::init<const opencascade::handle<Geom_BSplineCurve> &, const opencascade::handle<Geom2d_BSplineCurve> &, const opencascade::handle<Geom2d_BSplineCurve> &>(), py::arg("CurveXYZ"), py::arg("CurveUV1"), py::arg("CurveUV2"));
cls_BRepApprox_ApproxLine.def(py::init<const opencascade::handle<IntSurf_LineOn2S> &>(), py::arg("lin"));
cls_BRepApprox_ApproxLine.def(py::init<const opencascade::handle<IntSurf_LineOn2S> &, const Standard_Boolean>(), py::arg("lin"), py::arg("theTang"));

// Methods
cls_BRepApprox_ApproxLine.def("NbPnts", (Standard_Integer (BRepApprox_ApproxLine::*)() const) &BRepApprox_ApproxLine::NbPnts, "None");
cls_BRepApprox_ApproxLine.def("Point", (IntSurf_PntOn2S (BRepApprox_ApproxLine::*)(const Standard_Integer)) &BRepApprox_ApproxLine::Point, "None", py::arg("Index"));
cls_BRepApprox_ApproxLine.def_static("get_type_name_", (const char * (*)()) &BRepApprox_ApproxLine::get_type_name, "None");
cls_BRepApprox_ApproxLine.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &BRepApprox_ApproxLine::get_type_descriptor, "None");
cls_BRepApprox_ApproxLine.def("DynamicType", (const opencascade::handle<Standard_Type> & (BRepApprox_ApproxLine::*)() const) &BRepApprox_ApproxLine::DynamicType, "None");

// CLASS: BREPAPPROX_BSPGRADIENT_BFGSOFMYBSPLGRADIENTOFTHECOMPUTELINEOFAPPROX
py::class_<BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox, math_BFGS> cls_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox(mod, "BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox", "None");

// Constructors
cls_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"));
cls_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"), py::arg("NbIterations"));

// Methods
// cls_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox.def("IsSolutionReached", (Standard_Boolean (BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox::*)(math_MultipleVarFunctionWithGradient &) const) &BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox::IsSolutionReached, "None", py::arg("F"));

// CLASS: BREPAPPROX_THEMULTILINEOFAPPROX
py::class_<BRepApprox_TheMultiLineOfApprox> cls_BRepApprox_TheMultiLineOfApprox(mod, "BRepApprox_TheMultiLineOfApprox", "None");

// Constructors
cls_BRepApprox_TheMultiLineOfApprox.def(py::init<>());
cls_BRepApprox_TheMultiLineOfApprox.def(py::init<const opencascade::handle<BRepApprox_ApproxLine> &, const Standard_Address, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean>(), py::arg("line"), py::arg("PtrSvSurfaces"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"));
cls_BRepApprox_TheMultiLineOfApprox.def(py::init<const opencascade::handle<BRepApprox_ApproxLine> &, const Standard_Address, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer>(), py::arg("line"), py::arg("PtrSvSurfaces"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"), py::arg("IndMin"));
cls_BRepApprox_TheMultiLineOfApprox.def(py::init<const opencascade::handle<BRepApprox_ApproxLine> &, const Standard_Address, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer, const Standard_Integer>(), py::arg("line"), py::arg("PtrSvSurfaces"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"), py::arg("IndMin"), py::arg("IndMax"));
cls_BRepApprox_TheMultiLineOfApprox.def(py::init<const opencascade::handle<BRepApprox_ApproxLine> &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean>(), py::arg("line"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"));
cls_BRepApprox_TheMultiLineOfApprox.def(py::init<const opencascade::handle<BRepApprox_ApproxLine> &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer>(), py::arg("line"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"), py::arg("IndMin"));
cls_BRepApprox_TheMultiLineOfApprox.def(py::init<const opencascade::handle<BRepApprox_ApproxLine> &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer, const Standard_Integer>(), py::arg("line"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"), py::arg("IndMin"), py::arg("IndMax"));

// Methods
// cls_BRepApprox_TheMultiLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_TheMultiLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_TheMultiLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_TheMultiLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_TheMultiLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_TheMultiLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_TheMultiLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_TheMultiLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_TheMultiLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_TheMultiLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_TheMultiLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_TheMultiLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_TheMultiLineOfApprox.def("FirstPoint", (Standard_Integer (BRepApprox_TheMultiLineOfApprox::*)() const) &BRepApprox_TheMultiLineOfApprox::FirstPoint, "None");
cls_BRepApprox_TheMultiLineOfApprox.def("LastPoint", (Standard_Integer (BRepApprox_TheMultiLineOfApprox::*)() const) &BRepApprox_TheMultiLineOfApprox::LastPoint, "None");
cls_BRepApprox_TheMultiLineOfApprox.def("NbP2d", (Standard_Integer (BRepApprox_TheMultiLineOfApprox::*)() const) &BRepApprox_TheMultiLineOfApprox::NbP2d, "Returns the number of 2d points of a TheLine.");
cls_BRepApprox_TheMultiLineOfApprox.def("NbP3d", (Standard_Integer (BRepApprox_TheMultiLineOfApprox::*)() const) &BRepApprox_TheMultiLineOfApprox::NbP3d, "Returns the number of 3d points of a TheLine.");
cls_BRepApprox_TheMultiLineOfApprox.def("WhatStatus", (Approx_Status (BRepApprox_TheMultiLineOfApprox::*)() const) &BRepApprox_TheMultiLineOfApprox::WhatStatus, "None");
cls_BRepApprox_TheMultiLineOfApprox.def("Value", (void (BRepApprox_TheMultiLineOfApprox::*)(const Standard_Integer, TColgp_Array1OfPnt &) const) &BRepApprox_TheMultiLineOfApprox::Value, "Returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.", py::arg("MPointIndex"), py::arg("tabPt"));
cls_BRepApprox_TheMultiLineOfApprox.def("Value", (void (BRepApprox_TheMultiLineOfApprox::*)(const Standard_Integer, TColgp_Array1OfPnt2d &) const) &BRepApprox_TheMultiLineOfApprox::Value, "Returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.", py::arg("MPointIndex"), py::arg("tabPt2d"));
cls_BRepApprox_TheMultiLineOfApprox.def("Value", (void (BRepApprox_TheMultiLineOfApprox::*)(const Standard_Integer, TColgp_Array1OfPnt &, TColgp_Array1OfPnt2d &) const) &BRepApprox_TheMultiLineOfApprox::Value, "Returns the 3d and 2d points of the multipoint <MPointIndex>.", py::arg("MPointIndex"), py::arg("tabPt"), py::arg("tabPt2d"));
cls_BRepApprox_TheMultiLineOfApprox.def("Tangency", (Standard_Boolean (BRepApprox_TheMultiLineOfApprox::*)(const Standard_Integer, TColgp_Array1OfVec &) const) &BRepApprox_TheMultiLineOfApprox::Tangency, "Returns the 3d tangency points of the multipoint <MPointIndex> only when 3d points exist.", py::arg("MPointIndex"), py::arg("tabV"));
cls_BRepApprox_TheMultiLineOfApprox.def("Tangency", (Standard_Boolean (BRepApprox_TheMultiLineOfApprox::*)(const Standard_Integer, TColgp_Array1OfVec2d &) const) &BRepApprox_TheMultiLineOfApprox::Tangency, "Returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.", py::arg("MPointIndex"), py::arg("tabV2d"));
cls_BRepApprox_TheMultiLineOfApprox.def("Tangency", (Standard_Boolean (BRepApprox_TheMultiLineOfApprox::*)(const Standard_Integer, TColgp_Array1OfVec &, TColgp_Array1OfVec2d &) const) &BRepApprox_TheMultiLineOfApprox::Tangency, "Returns the 3d and 2d points of the multipoint <MPointIndex>.", py::arg("MPointIndex"), py::arg("tabV"), py::arg("tabV2d"));
cls_BRepApprox_TheMultiLineOfApprox.def("MakeMLBetween", (BRepApprox_TheMultiLineOfApprox (BRepApprox_TheMultiLineOfApprox::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer) const) &BRepApprox_TheMultiLineOfApprox::MakeMLBetween, "Tries to make a sub-line between <Low> and <High> points of this line by adding <NbPointsToInsert> new points", py::arg("Low"), py::arg("High"), py::arg("NbPointsToInsert"));
cls_BRepApprox_TheMultiLineOfApprox.def("MakeMLOneMorePoint", (Standard_Boolean (BRepApprox_TheMultiLineOfApprox::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, BRepApprox_TheMultiLineOfApprox &) const) &BRepApprox_TheMultiLineOfApprox::MakeMLOneMorePoint, "Tries to make a sub-line between <Low> and <High> points of this line by adding one more point between (indbad-1)-th and indbad-th points", py::arg("Low"), py::arg("High"), py::arg("indbad"), py::arg("OtherLine"));
cls_BRepApprox_TheMultiLineOfApprox.def("Dump", (void (BRepApprox_TheMultiLineOfApprox::*)() const) &BRepApprox_TheMultiLineOfApprox::Dump, "Dump of the current multi-line.");

// CLASS: BREPAPPROX_BSPPARLEASTSQUAREOFMYBSPLGRADIENTOFTHECOMPUTELINEOFAPPROX
py::class_<BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox> cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox(mod, "BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox", "None");

// Constructors
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));

// Methods
// cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("Perform", (void (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)(const math_Vector &)) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::Perform, "Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.", py::arg("Parameters"));
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("Perform", (void (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)(const math_Vector &, const Standard_Real, const Standard_Real)) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::Perform, "Is used after having initialized the fields.", py::arg("Parameters"), py::arg("l1"), py::arg("l2"));
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("Perform", (void (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("l1"), py::arg("l2"));
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("Perform", (void (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("V1c"), py::arg("V2c"), py::arg("l1"), py::arg("l2"));
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("IsDone", (Standard_Boolean (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::IsDone, "returns True if all has been correctly done.");
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("BezierValue", (AppParCurves_MultiCurve (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)()) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::BezierValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("BSplineValue", (const AppParCurves_MultiBSpCurve & (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)()) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::BSplineValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("FunctionMatrix", (const math_Matrix & (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::FunctionMatrix, "returns the function matrix used to approximate the set.");
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("DerivativeFunctionMatrix", (const math_Matrix & (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::DerivativeFunctionMatrix, "returns the derivative function matrix used to approximate the set.");
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("ErrorGradient", [](BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox &self, math_Vector & Grad, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.ErrorGradient(Grad, F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.", py::arg("Grad"), py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("Distance", (const math_Matrix & (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)()) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::Distance, "returns the distances between the points of the multiline and the approximation curves.");
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("Error", [](BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox &self, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.Error(F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.", py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("FirstLambda", (Standard_Real (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::FirstLambda, "returns the value (P2 - P1)/ V1 if the first point was a tangency point.");
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("LastLambda", (Standard_Real (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::LastLambda, "returns the value (PN - PN-1)/ VN if the last point was a tangency point.");
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("Points", (const math_Matrix & (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::Points, "returns the matrix of points value.");
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("Poles", (const math_Matrix & (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::Poles, "returns the matrix of resulting control points value.");
cls_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.def("KIndex", (const math_IntegerVector & (BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox::KIndex, "Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.");

// CLASS: BREPAPPROX_BSPPARFUNCTIONOFMYBSPLGRADIENTOFTHECOMPUTELINEOFAPPROX
py::class_<BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox, math_MultipleVarFunctionWithGradient> cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox(mod, "BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox", "None");

// Constructors
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Vector &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Knots"), py::arg("Mults"), py::arg("NbPol"));

// Methods
// cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("NbVariables", (Standard_Integer (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::NbVariables, "returns the number of variables of the function. It corresponds to the number of MultiPoints.");
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("Value", [](BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox &self, const math_Vector & X, Standard_Real & F){ Standard_Boolean rv = self.Value(X, F); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "this method computes the new approximation of the MultiLine SSP and calculates F = sum (||Pui - Bi*Pi||2) for each point of the MultiLine.", py::arg("X"), py::arg("F"));
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("Gradient", (Standard_Boolean (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)(const math_Vector &, math_Vector &)) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::Gradient, "returns the gradient G of the sum above for the parameters Xi.", py::arg("X"), py::arg("G"));
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("Values", [](BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox &self, const math_Vector & X, Standard_Real & F, math_Vector & G){ Standard_Boolean rv = self.Values(X, F, G); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "returns the value F=sum(||Pui - Bi*Pi||)2. returns the value G = grad(F) for the parameters Xi.", py::arg("X"), py::arg("F"), py::arg("G"));
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("NewParameters", (const math_Vector & (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::NewParameters, "returns the new parameters of the MultiLine.");
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("CurveValue", (AppParCurves_MultiBSpCurve (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)()) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::CurveValue, "returns the MultiBSpCurve approximating the set after computing the value F or Grad(F).");
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("Error", (Standard_Real (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)(const Standard_Integer, const Standard_Integer)) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::Error, "returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.", py::arg("IPoint"), py::arg("CurveIndex"));
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("MaxError3d", (Standard_Real (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::MaxError3d, "returns the maximum distance between the points and the MultiBSpCurve.");
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("MaxError2d", (Standard_Real (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::MaxError2d, "returns the maximum distance between the points and the MultiBSpCurve.");
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("FunctionMatrix", (const math_Matrix & (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::FunctionMatrix, "returns the function matrix used to approximate the multiline.");
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("DerivativeFunctionMatrix", (const math_Matrix & (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::DerivativeFunctionMatrix, "returns the derivative function matrix used to approximate the multiline.");
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("Index", (const math_IntegerVector & (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::Index, "Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.");
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("FirstConstraint", (AppParCurves_Constraint (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::FirstConstraint, "None", py::arg("TheConstraints"), py::arg("FirstPoint"));
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("LastConstraint", (AppParCurves_Constraint (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::LastConstraint, "None", py::arg("TheConstraints"), py::arg("LastPoint"));
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("SetFirstLambda", (void (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)(const Standard_Real)) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::SetFirstLambda, "None", py::arg("l1"));
cls_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.def("SetLastLambda", (void (BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::*)(const Standard_Real)) &BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox::SetLastLambda, "None", py::arg("l2"));

// CLASS: BREPAPPROX_GRADIENT_BFGSOFMYGRADIENTBISOFTHECOMPUTELINEOFAPPROX
py::class_<BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox, math_BFGS> cls_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox(mod, "BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox", "None");

// Constructors
cls_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"));
cls_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"), py::arg("NbIterations"));

// Methods
// cls_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox.def("IsSolutionReached", (Standard_Boolean (BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox::*)(math_MultipleVarFunctionWithGradient &) const) &BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox::IsSolutionReached, "None", py::arg("F"));

// CLASS: BREPAPPROX_GRADIENT_BFGSOFMYGRADIENTOFTHECOMPUTELINEBEZIEROFAPPROX
py::class_<BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox, math_BFGS> cls_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox(mod, "BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox", "None");

// Constructors
cls_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"));
cls_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"), py::arg("NbIterations"));

// Methods
// cls_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox.def("IsSolutionReached", (Standard_Boolean (BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox::*)(math_MultipleVarFunctionWithGradient &) const) &BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox::IsSolutionReached, "None", py::arg("F"));

// CLASS: BREPAPPROX_MYBSPLGRADIENTOFTHECOMPUTELINEOFAPPROX
py::class_<BRepApprox_MyBSplGradientOfTheComputeLineOfApprox> cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox(mod, "BRepApprox_MyBSplGradientOfTheComputeLineOfApprox", "None");

// Constructors
cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Knots"), py::arg("Mults"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"));
cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Knots"), py::arg("Mults"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"), py::arg("NbIterations"));
cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Knots"), py::arg("Mults"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"), py::arg("NbIterations"), py::arg("lambda1"), py::arg("lambda2"));

// Methods
// cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def("IsDone", (Standard_Boolean (BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::IsDone, "returns True if all has been correctly done.");
cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def("Value", (AppParCurves_MultiBSpCurve (BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::Value, "returns all the BSpline curves approximating the MultiLine SSP after minimization of the parameter.");
cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def("Error", (Standard_Real (BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::*)(const Standard_Integer) const) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::Error, "returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.", py::arg("Index"));
cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def("MaxError3d", (Standard_Real (BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::MaxError3d, "returns the maximum difference between the old and the new approximation.");
cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def("MaxError2d", (Standard_Real (BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::MaxError2d, "returns the maximum difference between the old and the new approximation.");
cls_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.def("AverageError", (Standard_Real (BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::*)() const) &BRepApprox_MyBSplGradientOfTheComputeLineOfApprox::AverageError, "returns the average error between the old and the new approximation.");

// CLASS: BREPAPPROX_MYGRADIENTBISOFTHECOMPUTELINEOFAPPROX
py::class_<BRepApprox_MyGradientbisOfTheComputeLineOfApprox> cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox(mod, "BRepApprox_MyGradientbisOfTheComputeLineOfApprox", "None");

// Constructors
cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"));
cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"), py::arg("NbIterations"));

// Methods
// cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def("IsDone", (Standard_Boolean (BRepApprox_MyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::IsDone, "returns True if all has been correctly done.");
cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def("Value", (AppParCurves_MultiCurve (BRepApprox_MyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::Value, "returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.");
cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def("Error", (Standard_Real (BRepApprox_MyGradientbisOfTheComputeLineOfApprox::*)(const Standard_Integer) const) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::Error, "returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.", py::arg("Index"));
cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def("MaxError3d", (Standard_Real (BRepApprox_MyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::MaxError3d, "returns the maximum difference between the old and the new approximation.");
cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def("MaxError2d", (Standard_Real (BRepApprox_MyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::MaxError2d, "returns the maximum difference between the old and the new approximation.");
cls_BRepApprox_MyGradientbisOfTheComputeLineOfApprox.def("AverageError", (Standard_Real (BRepApprox_MyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_MyGradientbisOfTheComputeLineOfApprox::AverageError, "returns the average error between the old and the new approximation.");

// CLASS: BREPAPPROX_MYGRADIENTOFTHECOMPUTELINEBEZIEROFAPPROX
py::class_<BRepApprox_MyGradientOfTheComputeLineBezierOfApprox> cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox(mod, "BRepApprox_MyGradientOfTheComputeLineBezierOfApprox", "None");

// Constructors
cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"));
cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"), py::arg("NbIterations"));

// Methods
// cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def("IsDone", (Standard_Boolean (BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::IsDone, "returns True if all has been correctly done.");
cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def("Value", (AppParCurves_MultiCurve (BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::Value, "returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.");
cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def("Error", (Standard_Real (BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::*)(const Standard_Integer) const) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::Error, "returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.", py::arg("Index"));
cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def("MaxError3d", (Standard_Real (BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::MaxError3d, "returns the maximum difference between the old and the new approximation.");
cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def("MaxError2d", (Standard_Real (BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::MaxError2d, "returns the maximum difference between the old and the new approximation.");
cls_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.def("AverageError", (Standard_Real (BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_MyGradientOfTheComputeLineBezierOfApprox::AverageError, "returns the average error between the old and the new approximation.");

// CLASS: BREPAPPROX_PARLEASTSQUAREOFMYGRADIENTBISOFTHECOMPUTELINEOFAPPROX
py::class_<BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox> cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox(mod, "BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox", "None");

// Constructors
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));

// Methods
// cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("Perform", (void (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)(const math_Vector &)) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::Perform, "Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.", py::arg("Parameters"));
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("Perform", (void (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)(const math_Vector &, const Standard_Real, const Standard_Real)) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::Perform, "Is used after having initialized the fields.", py::arg("Parameters"), py::arg("l1"), py::arg("l2"));
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("Perform", (void (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("l1"), py::arg("l2"));
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("Perform", (void (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("V1c"), py::arg("V2c"), py::arg("l1"), py::arg("l2"));
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("IsDone", (Standard_Boolean (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::IsDone, "returns True if all has been correctly done.");
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("BezierValue", (AppParCurves_MultiCurve (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)()) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::BezierValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("BSplineValue", (const AppParCurves_MultiBSpCurve & (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)()) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::BSplineValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("FunctionMatrix", (const math_Matrix & (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::FunctionMatrix, "returns the function matrix used to approximate the set.");
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("DerivativeFunctionMatrix", (const math_Matrix & (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::DerivativeFunctionMatrix, "returns the derivative function matrix used to approximate the set.");
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("ErrorGradient", [](BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox &self, math_Vector & Grad, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.ErrorGradient(Grad, F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.", py::arg("Grad"), py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("Distance", (const math_Matrix & (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)()) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::Distance, "returns the distances between the points of the multiline and the approximation curves.");
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("Error", [](BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox &self, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.Error(F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.", py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("FirstLambda", (Standard_Real (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::FirstLambda, "returns the value (P2 - P1)/ V1 if the first point was a tangency point.");
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("LastLambda", (Standard_Real (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::LastLambda, "returns the value (PN - PN-1)/ VN if the last point was a tangency point.");
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("Points", (const math_Matrix & (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::Points, "returns the matrix of points value.");
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("Poles", (const math_Matrix & (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::Poles, "returns the matrix of resulting control points value.");
cls_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.def("KIndex", (const math_IntegerVector & (BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox::KIndex, "Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.");

// CLASS: BREPAPPROX_PARFUNCTIONOFMYGRADIENTBISOFTHECOMPUTELINEOFAPPROX
py::class_<BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox, math_MultipleVarFunctionWithGradient> cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox(mod, "BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox", "None");

// Constructors
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"));

// Methods
// cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("NbVariables", (Standard_Integer (BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::NbVariables, "returns the number of variables of the function. It corresponds to the number of MultiPoints.");
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("Value", [](BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox &self, const math_Vector & X, Standard_Real & F){ Standard_Boolean rv = self.Value(X, F); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "this method computes the new approximation of the MultiLine SSP and calculates F = sum (||Pui - Bi*Pi||2) for each point of the MultiLine.", py::arg("X"), py::arg("F"));
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("Gradient", (Standard_Boolean (BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::*)(const math_Vector &, math_Vector &)) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::Gradient, "returns the gradient G of the sum above for the parameters Xi.", py::arg("X"), py::arg("G"));
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("Values", [](BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox &self, const math_Vector & X, Standard_Real & F, math_Vector & G){ Standard_Boolean rv = self.Values(X, F, G); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "returns the value F=sum(||Pui - Bi*Pi||)2. returns the value G = grad(F) for the parameters Xi.", py::arg("X"), py::arg("F"), py::arg("G"));
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("NewParameters", (const math_Vector & (BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::NewParameters, "returns the new parameters of the MultiLine.");
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("CurveValue", (const AppParCurves_MultiCurve & (BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::*)()) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::CurveValue, "returns the MultiCurve approximating the set after computing the value F or Grad(F).");
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("Error", (Standard_Real (BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::*)(const Standard_Integer, const Standard_Integer) const) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::Error, "returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.", py::arg("IPoint"), py::arg("CurveIndex"));
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("MaxError3d", (Standard_Real (BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::MaxError3d, "returns the maximum distance between the points and the MultiCurve.");
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("MaxError2d", (Standard_Real (BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::MaxError2d, "returns the maximum distance between the points and the MultiCurve.");
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("FirstConstraint", (AppParCurves_Constraint (BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::FirstConstraint, "None", py::arg("TheConstraints"), py::arg("FirstPoint"));
cls_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.def("LastConstraint", (AppParCurves_Constraint (BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const) &BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox::LastConstraint, "None", py::arg("TheConstraints"), py::arg("LastPoint"));

// CLASS: BREPAPPROX_PARLEASTSQUAREOFMYGRADIENTOFTHECOMPUTELINEBEZIEROFAPPROX
py::class_<BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox> cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox(mod, "BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox", "None");

// Constructors
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));

// Methods
// cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("Perform", (void (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)(const math_Vector &)) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::Perform, "Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.", py::arg("Parameters"));
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("Perform", (void (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)(const math_Vector &, const Standard_Real, const Standard_Real)) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::Perform, "Is used after having initialized the fields.", py::arg("Parameters"), py::arg("l1"), py::arg("l2"));
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("Perform", (void (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("l1"), py::arg("l2"));
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("Perform", (void (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("V1c"), py::arg("V2c"), py::arg("l1"), py::arg("l2"));
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("IsDone", (Standard_Boolean (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::IsDone, "returns True if all has been correctly done.");
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("BezierValue", (AppParCurves_MultiCurve (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)()) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::BezierValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("BSplineValue", (const AppParCurves_MultiBSpCurve & (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)()) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::BSplineValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("FunctionMatrix", (const math_Matrix & (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::FunctionMatrix, "returns the function matrix used to approximate the set.");
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("DerivativeFunctionMatrix", (const math_Matrix & (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::DerivativeFunctionMatrix, "returns the derivative function matrix used to approximate the set.");
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("ErrorGradient", [](BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox &self, math_Vector & Grad, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.ErrorGradient(Grad, F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.", py::arg("Grad"), py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("Distance", (const math_Matrix & (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)()) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::Distance, "returns the distances between the points of the multiline and the approximation curves.");
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("Error", [](BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox &self, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.Error(F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.", py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("FirstLambda", (Standard_Real (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::FirstLambda, "returns the value (P2 - P1)/ V1 if the first point was a tangency point.");
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("LastLambda", (Standard_Real (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::LastLambda, "returns the value (PN - PN-1)/ VN if the last point was a tangency point.");
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("Points", (const math_Matrix & (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::Points, "returns the matrix of points value.");
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("Poles", (const math_Matrix & (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::Poles, "returns the matrix of resulting control points value.");
cls_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.def("KIndex", (const math_IntegerVector & (BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox::KIndex, "Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.");

// CLASS: BREPAPPROX_PARFUNCTIONOFMYGRADIENTOFTHECOMPUTELINEBEZIEROFAPPROX
py::class_<BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox, math_MultipleVarFunctionWithGradient> cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox(mod, "BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox", "None");

// Constructors
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"));

// Methods
// cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("NbVariables", (Standard_Integer (BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::NbVariables, "returns the number of variables of the function. It corresponds to the number of MultiPoints.");
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("Value", [](BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox &self, const math_Vector & X, Standard_Real & F){ Standard_Boolean rv = self.Value(X, F); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "this method computes the new approximation of the MultiLine SSP and calculates F = sum (||Pui - Bi*Pi||2) for each point of the MultiLine.", py::arg("X"), py::arg("F"));
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("Gradient", (Standard_Boolean (BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::*)(const math_Vector &, math_Vector &)) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::Gradient, "returns the gradient G of the sum above for the parameters Xi.", py::arg("X"), py::arg("G"));
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("Values", [](BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox &self, const math_Vector & X, Standard_Real & F, math_Vector & G){ Standard_Boolean rv = self.Values(X, F, G); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "returns the value F=sum(||Pui - Bi*Pi||)2. returns the value G = grad(F) for the parameters Xi.", py::arg("X"), py::arg("F"), py::arg("G"));
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("NewParameters", (const math_Vector & (BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::NewParameters, "returns the new parameters of the MultiLine.");
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("CurveValue", (const AppParCurves_MultiCurve & (BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::*)()) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::CurveValue, "returns the MultiCurve approximating the set after computing the value F or Grad(F).");
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("Error", (Standard_Real (BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::*)(const Standard_Integer, const Standard_Integer) const) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::Error, "returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.", py::arg("IPoint"), py::arg("CurveIndex"));
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("MaxError3d", (Standard_Real (BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::MaxError3d, "returns the maximum distance between the points and the MultiCurve.");
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("MaxError2d", (Standard_Real (BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::MaxError2d, "returns the maximum distance between the points and the MultiCurve.");
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("FirstConstraint", (AppParCurves_Constraint (BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::FirstConstraint, "None", py::arg("TheConstraints"), py::arg("FirstPoint"));
cls_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.def("LastConstraint", (AppParCurves_Constraint (BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const) &BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox::LastConstraint, "None", py::arg("TheConstraints"), py::arg("LastPoint"));

// CLASS: BREPAPPROX_RESCONSTRAINTOFMYGRADIENTBISOFTHECOMPUTELINEOFAPPROX
py::class_<BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox> cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox(mod, "BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox", "None");

// Constructors
cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, AppParCurves_MultiCurve &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Matrix &, const math_Matrix &>(), py::arg("SSP"), py::arg("SCurv"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("Constraints"), py::arg("Bern"), py::arg("DerivativeBern"));
cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, AppParCurves_MultiCurve &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Matrix &, const math_Matrix &, const Standard_Real>(), py::arg("SSP"), py::arg("SCurv"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("Constraints"), py::arg("Bern"), py::arg("DerivativeBern"), py::arg("Tolerance"));

// Methods
// cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def("IsDone", (Standard_Boolean (BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::IsDone, "returns True if all has been correctly done.");
// cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def("Error", (Standard_Real (BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::Error, "returns the maximum difference value between the curve and the given points.");
cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def("ConstraintMatrix", (const math_Matrix & (BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::ConstraintMatrix, "None");
cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def("Duale", (const math_Vector & (BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::Duale, "returns the duale variables of the system.");
cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def("ConstraintDerivative", (const math_Matrix & (BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::*)(const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const math_Matrix &)) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::ConstraintDerivative, "Returns the derivative of the constraint matrix.", py::arg("SSP"), py::arg("Parameters"), py::arg("Deg"), py::arg("DA"));
cls_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.def("InverseMatrix", (const math_Matrix & (BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::*)() const) &BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox::InverseMatrix, "returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.");

// CLASS: BREPAPPROX_RESCONSTRAINTOFMYGRADIENTOFTHECOMPUTELINEBEZIEROFAPPROX
py::class_<BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox> cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox(mod, "BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox", "None");

// Constructors
cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, AppParCurves_MultiCurve &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Matrix &, const math_Matrix &>(), py::arg("SSP"), py::arg("SCurv"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("Constraints"), py::arg("Bern"), py::arg("DerivativeBern"));
cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def(py::init<const BRepApprox_TheMultiLineOfApprox &, AppParCurves_MultiCurve &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Matrix &, const math_Matrix &, const Standard_Real>(), py::arg("SSP"), py::arg("SCurv"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("Constraints"), py::arg("Bern"), py::arg("DerivativeBern"), py::arg("Tolerance"));

// Methods
// cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def("IsDone", (Standard_Boolean (BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::IsDone, "returns True if all has been correctly done.");
// cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def("Error", (Standard_Real (BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::Error, "returns the maximum difference value between the curve and the given points.");
cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def("ConstraintMatrix", (const math_Matrix & (BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::ConstraintMatrix, "None");
cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def("Duale", (const math_Vector & (BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::Duale, "returns the duale variables of the system.");
cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def("ConstraintDerivative", (const math_Matrix & (BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::*)(const BRepApprox_TheMultiLineOfApprox &, const math_Vector &, const Standard_Integer, const math_Matrix &)) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::ConstraintDerivative, "Returns the derivative of the constraint matrix.", py::arg("SSP"), py::arg("Parameters"), py::arg("Deg"), py::arg("DA"));
cls_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.def("InverseMatrix", (const math_Matrix & (BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::*)() const) &BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox::InverseMatrix, "returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.");

// CLASS: BREPAPPROX_SURFACETOOL
py::class_<BRepApprox_SurfaceTool> cls_BRepApprox_SurfaceTool(mod, "BRepApprox_SurfaceTool", "None");

// Methods
// cls_BRepApprox_SurfaceTool.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_SurfaceTool::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_SurfaceTool.def_static("operator delete_", (void (*)(void *)) &BRepApprox_SurfaceTool::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_SurfaceTool.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_SurfaceTool::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_SurfaceTool.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_SurfaceTool::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_SurfaceTool.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_SurfaceTool::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_SurfaceTool.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_SurfaceTool::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_SurfaceTool.def_static("FirstUParameter_", (Standard_Real (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::FirstUParameter, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("FirstVParameter_", (Standard_Real (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::FirstVParameter, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("LastUParameter_", (Standard_Real (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::LastUParameter, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("LastVParameter_", (Standard_Real (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::LastVParameter, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("NbUIntervals_", (Standard_Integer (*)(const BRepAdaptor_Surface &, const GeomAbs_Shape)) &BRepApprox_SurfaceTool::NbUIntervals, "None", py::arg("S"), py::arg("Sh"));
cls_BRepApprox_SurfaceTool.def_static("NbVIntervals_", (Standard_Integer (*)(const BRepAdaptor_Surface &, const GeomAbs_Shape)) &BRepApprox_SurfaceTool::NbVIntervals, "None", py::arg("S"), py::arg("Sh"));
cls_BRepApprox_SurfaceTool.def_static("UIntervals_", (void (*)(const BRepAdaptor_Surface &, TColStd_Array1OfReal &, const GeomAbs_Shape)) &BRepApprox_SurfaceTool::UIntervals, "None", py::arg("S"), py::arg("T"), py::arg("Sh"));
cls_BRepApprox_SurfaceTool.def_static("VIntervals_", (void (*)(const BRepAdaptor_Surface &, TColStd_Array1OfReal &, const GeomAbs_Shape)) &BRepApprox_SurfaceTool::VIntervals, "None", py::arg("S"), py::arg("T"), py::arg("Sh"));
cls_BRepApprox_SurfaceTool.def_static("UTrim_", (opencascade::handle<Adaptor3d_HSurface> (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real, const Standard_Real)) &BRepApprox_SurfaceTool::UTrim, "If <First> >= <Last>", py::arg("S"), py::arg("First"), py::arg("Last"), py::arg("Tol"));
cls_BRepApprox_SurfaceTool.def_static("VTrim_", (opencascade::handle<Adaptor3d_HSurface> (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real, const Standard_Real)) &BRepApprox_SurfaceTool::VTrim, "If <First> >= <Last>", py::arg("S"), py::arg("First"), py::arg("Last"), py::arg("Tol"));
cls_BRepApprox_SurfaceTool.def_static("IsUClosed_", (Standard_Boolean (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::IsUClosed, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("IsVClosed_", (Standard_Boolean (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::IsVClosed, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("IsUPeriodic_", (Standard_Boolean (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::IsUPeriodic, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("UPeriod_", (Standard_Real (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::UPeriod, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("IsVPeriodic_", (Standard_Boolean (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::IsVPeriodic, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("VPeriod_", (Standard_Real (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::VPeriod, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("Value_", (gp_Pnt (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real)) &BRepApprox_SurfaceTool::Value, "None", py::arg("S"), py::arg("u"), py::arg("v"));
cls_BRepApprox_SurfaceTool.def_static("D0_", (void (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real, gp_Pnt &)) &BRepApprox_SurfaceTool::D0, "None", py::arg("S"), py::arg("u"), py::arg("v"), py::arg("P"));
cls_BRepApprox_SurfaceTool.def_static("D1_", (void (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &)) &BRepApprox_SurfaceTool::D1, "None", py::arg("S"), py::arg("u"), py::arg("v"), py::arg("P"), py::arg("D1u"), py::arg("D1v"));
cls_BRepApprox_SurfaceTool.def_static("D2_", (void (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &BRepApprox_SurfaceTool::D2, "None", py::arg("S"), py::arg("u"), py::arg("v"), py::arg("P"), py::arg("D1U"), py::arg("D1V"), py::arg("D2U"), py::arg("D2V"), py::arg("D2UV"));
cls_BRepApprox_SurfaceTool.def_static("D3_", (void (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &BRepApprox_SurfaceTool::D3, "None", py::arg("S"), py::arg("u"), py::arg("v"), py::arg("P"), py::arg("D1U"), py::arg("D1V"), py::arg("D2U"), py::arg("D2V"), py::arg("D2UV"), py::arg("D3U"), py::arg("D3V"), py::arg("D3UUV"), py::arg("D3UVV"));
cls_BRepApprox_SurfaceTool.def_static("DN_", (gp_Vec (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer)) &BRepApprox_SurfaceTool::DN, "None", py::arg("S"), py::arg("u"), py::arg("v"), py::arg("Nu"), py::arg("Nv"));
cls_BRepApprox_SurfaceTool.def_static("UResolution_", (Standard_Real (*)(const BRepAdaptor_Surface &, const Standard_Real)) &BRepApprox_SurfaceTool::UResolution, "None", py::arg("S"), py::arg("R3d"));
cls_BRepApprox_SurfaceTool.def_static("VResolution_", (Standard_Real (*)(const BRepAdaptor_Surface &, const Standard_Real)) &BRepApprox_SurfaceTool::VResolution, "None", py::arg("S"), py::arg("R3d"));
cls_BRepApprox_SurfaceTool.def_static("GetType_", (GeomAbs_SurfaceType (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::GetType, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("Plane_", (gp_Pln (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::Plane, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("Cylinder_", (gp_Cylinder (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::Cylinder, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("Cone_", (gp_Cone (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::Cone, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("Torus_", (gp_Torus (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::Torus, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("Sphere_", (gp_Sphere (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::Sphere, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("Bezier_", (opencascade::handle<Geom_BezierSurface> (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::Bezier, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("BSpline_", (opencascade::handle<Geom_BSplineSurface> (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::BSpline, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("AxeOfRevolution_", (gp_Ax1 (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::AxeOfRevolution, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("Direction_", (gp_Dir (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::Direction, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("BasisCurve_", (opencascade::handle<Adaptor3d_HCurve> (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::BasisCurve, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("NbSamplesU_", (Standard_Integer (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::NbSamplesU, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("NbSamplesV_", (Standard_Integer (*)(const BRepAdaptor_Surface &)) &BRepApprox_SurfaceTool::NbSamplesV, "None", py::arg("S"));
cls_BRepApprox_SurfaceTool.def_static("NbSamplesU_", (Standard_Integer (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real)) &BRepApprox_SurfaceTool::NbSamplesU, "None", py::arg("S"), py::arg("u1"), py::arg("u2"));
cls_BRepApprox_SurfaceTool.def_static("NbSamplesV_", (Standard_Integer (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real)) &BRepApprox_SurfaceTool::NbSamplesV, "None", py::arg("S"), py::arg("v1"), py::arg("v2"));

// CLASS: BREPAPPROX_THEFUNCTIONOFTHEINT2SOFTHEPRMPRMSVSURFACESOFAPPROX
py::class_<BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox, math_FunctionSetWithDerivatives> cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox(mod, "BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox", "None");

// Constructors
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def(py::init<const BRepAdaptor_Surface &, const BRepAdaptor_Surface &>(), py::arg("S1"), py::arg("S2"));

// Methods
// cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("NbVariables", (Standard_Integer (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::NbVariables, "None");
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("NbEquations", (Standard_Integer (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::NbEquations, "None");
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Value", (Standard_Boolean (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)(const math_Vector &, math_Vector &)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::Value, "None", py::arg("X"), py::arg("F"));
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Derivatives", (Standard_Boolean (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)(const math_Vector &, math_Matrix &)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::Derivatives, "None", py::arg("X"), py::arg("D"));
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Values", (Standard_Boolean (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)(const math_Vector &, math_Vector &, math_Matrix &)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::Values, "None", py::arg("X"), py::arg("F"), py::arg("D"));
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("ComputeParameters", (void (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)(const IntImp_ConstIsoparametric, const TColStd_Array1OfReal &, math_Vector &, math_Vector &, math_Vector &, math_Vector &)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::ComputeParameters, "None", py::arg("ChoixIso"), py::arg("Param"), py::arg("UVap"), py::arg("BornInf"), py::arg("BornSup"), py::arg("Tolerance"));
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Root", (Standard_Real (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::Root, "returns somme des fi*fi");
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Point", (gp_Pnt (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::Point, "None");
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("IsTangent", (Standard_Boolean (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)(const math_Vector &, TColStd_Array1OfReal &, IntImp_ConstIsoparametric &)) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::IsTangent, "None", py::arg("UVap"), py::arg("Param"), py::arg("BestChoix"));
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Direction", (gp_Dir (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::Direction, "None");
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("DirectionOnS1", (gp_Dir2d (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::DirectionOnS1, "None");
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("DirectionOnS2", (gp_Dir2d (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::DirectionOnS2, "None");
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("AuxillarSurface1", (const BRepAdaptor_Surface & (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::AuxillarSurface1, "None");
cls_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.def("AuxillarSurface2", (const BRepAdaptor_Surface & (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox::AuxillarSurface2, "None");

// CLASS: BREPAPPROX_THEZERIMPFUNCOFTHEIMPPRMSVSURFACESOFAPPROX
py::class_<BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox, math_FunctionSetWithDerivatives> cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox(mod, "BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox", "None");

// Constructors
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def(py::init<>());
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def(py::init<const BRepAdaptor_Surface &, const IntSurf_Quadric &>(), py::arg("PS"), py::arg("IS"));
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def(py::init<const IntSurf_Quadric &>(), py::arg("IS"));

// Methods
// cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("Set", (void (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)(const BRepAdaptor_Surface &)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::Set, "None", py::arg("PS"));
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("SetImplicitSurface", (void (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)(const IntSurf_Quadric &)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::SetImplicitSurface, "None", py::arg("IS"));
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("Set", (void (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)(const Standard_Real)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::Set, "None", py::arg("Tolerance"));
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("NbVariables", (Standard_Integer (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::NbVariables, "None");
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("NbEquations", (Standard_Integer (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::NbEquations, "None");
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("Value", (Standard_Boolean (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)(const math_Vector &, math_Vector &)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::Value, "None", py::arg("X"), py::arg("F"));
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("Derivatives", (Standard_Boolean (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)(const math_Vector &, math_Matrix &)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::Derivatives, "None", py::arg("X"), py::arg("D"));
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("Values", (Standard_Boolean (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)(const math_Vector &, math_Vector &, math_Matrix &)) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::Values, "None", py::arg("X"), py::arg("F"), py::arg("D"));
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("Root", (Standard_Real (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::Root, "None");
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("Tolerance", (Standard_Real (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::Tolerance, "Returns the value Tol so that if Abs(Func.Root())<Tol the function is considered null.");
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("Point", (const gp_Pnt & (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::Point, "None");
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("IsTangent", (Standard_Boolean (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)()) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::IsTangent, "None");
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("Direction3d", (const gp_Vec & (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)()) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::Direction3d, "None");
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("Direction2d", (const gp_Dir2d & (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)()) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::Direction2d, "None");
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("PSurface", (const BRepAdaptor_Surface & (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::PSurface, "None");
cls_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.def("ISurface", (const IntSurf_Quadric & (BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox::ISurface, "None");

// CLASS: BREPAPPROX_THEIMPPRMSVSURFACESOFAPPROX
py::class_<BRepApprox_TheImpPrmSvSurfacesOfApprox, ApproxInt_SvSurfaces> cls_BRepApprox_TheImpPrmSvSurfacesOfApprox(mod, "BRepApprox_TheImpPrmSvSurfacesOfApprox", "None");

// Constructors
cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def(py::init<const BRepAdaptor_Surface &, const IntSurf_Quadric &>(), py::arg("Surf1"), py::arg("Surf2"));
cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def(py::init<const IntSurf_Quadric &, const BRepAdaptor_Surface &>(), py::arg("Surf1"), py::arg("Surf2"));

// Methods
// cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def("Compute", [](BRepApprox_TheImpPrmSvSurfacesOfApprox &self, Standard_Real & u1, Standard_Real & v1, Standard_Real & u2, Standard_Real & v2, gp_Pnt & Pt, gp_Vec & Tg, gp_Vec2d & Tguv1, gp_Vec2d & Tguv2){ Standard_Boolean rv = self.Compute(u1, v1, u2, v2, Pt, Tg, Tguv1, Tguv2); return std::tuple<Standard_Boolean, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &>(rv, u1, v1, u2, v2); }, "returns True if Tg,Tguv1 Tguv2 can be computed.", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Pt"), py::arg("Tg"), py::arg("Tguv1"), py::arg("Tguv2"));
cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def("Pnt", (void (BRepApprox_TheImpPrmSvSurfacesOfApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Pnt &)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::Pnt, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("P"));
cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def("SeekPoint", (Standard_Boolean (BRepApprox_TheImpPrmSvSurfacesOfApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, IntSurf_PntOn2S &)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::SeekPoint, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Point"));
cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def("Tangency", (Standard_Boolean (BRepApprox_TheImpPrmSvSurfacesOfApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec &)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::Tangency, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));
cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def("TangencyOnSurf1", (Standard_Boolean (BRepApprox_TheImpPrmSvSurfacesOfApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec2d &)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::TangencyOnSurf1, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));
cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def("TangencyOnSurf2", (Standard_Boolean (BRepApprox_TheImpPrmSvSurfacesOfApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec2d &)) &BRepApprox_TheImpPrmSvSurfacesOfApprox::TangencyOnSurf2, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));
// cls_BRepApprox_TheImpPrmSvSurfacesOfApprox.def("FillInitialVectorOfSolution", [](BRepApprox_TheImpPrmSvSurfacesOfApprox &self, const Standard_Real u1, const Standard_Real v1, const Standard_Real u2, const Standard_Real v2, const Standard_Real binfu, const Standard_Real bsupu, const Standard_Real binfv, const Standard_Real bsupv, math_Vector & X, Standard_Real & TranslationU, Standard_Real & TranslationV){ Standard_Boolean rv = self.FillInitialVectorOfSolution(u1, v1, u2, v2, binfu, bsupu, binfv, bsupv, X, TranslationU, TranslationV); return std::tuple<Standard_Boolean, Standard_Real &, Standard_Real &>(rv, TranslationU, TranslationV); }, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("binfu"), py::arg("bsupu"), py::arg("binfv"), py::arg("bsupv"), py::arg("X"), py::arg("TranslationU"), py::arg("TranslationV"));

// CLASS: BREPAPPROX_THEINT2SOFTHEPRMPRMSVSURFACESOFAPPROX
py::class_<BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox> cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox(mod, "BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox", "None");

// Constructors
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def(py::init<const TColStd_Array1OfReal &, const BRepAdaptor_Surface &, const BRepAdaptor_Surface &, const Standard_Real>(), py::arg("Param"), py::arg("S1"), py::arg("S2"), py::arg("TolTangency"));
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def(py::init<const BRepAdaptor_Surface &, const BRepAdaptor_Surface &, const Standard_Real>(), py::arg("S1"), py::arg("S2"), py::arg("TolTangency"));

// Methods
// cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Perform", (IntImp_ConstIsoparametric (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)(const TColStd_Array1OfReal &, math_FunctionSetRoot &)) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::Perform, "returns the best constant isoparametric to find the next intersection's point +stores the solution point (the solution point is found with the close point to intersect the isoparametric with the other patch; the choice of the isoparametic is calculated)", py::arg("Param"), py::arg("Rsnld"));
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Perform", (IntImp_ConstIsoparametric (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)(const TColStd_Array1OfReal &, math_FunctionSetRoot &, const IntImp_ConstIsoparametric)) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::Perform, "returns the best constant isoparametric to find the next intersection's point +stores the solution point (the solution point is found with the close point to intersect the isoparametric with the other patch; the choice of the isoparametic is given by ChoixIso)", py::arg("Param"), py::arg("Rsnld"), py::arg("ChoixIso"));
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("IsDone", (Standard_Boolean (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::IsDone, "Returns TRUE if the creation completed without failure.");
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("IsEmpty", (Standard_Boolean (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::IsEmpty, "Returns TRUE when there is no solution to the problem.");
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Point", (const IntSurf_PntOn2S & (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::Point, "Returns the intersection point.");
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("IsTangent", (Standard_Boolean (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::IsTangent, "Returns True if the surfaces are tangent at the intersection point.");
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Direction", (const gp_Dir & (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::Direction, "Returns the tangent at the intersection line.");
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("DirectionOnS1", (const gp_Dir2d & (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::DirectionOnS1, "Returns the tangent at the intersection line in the parametric space of the first surface.");
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("DirectionOnS2", (const gp_Dir2d & (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)() const) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::DirectionOnS2, "Returns the tangent at the intersection line in the parametric space of the second surface.");
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("Function", (BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox & (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)()) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::Function, "return the math function which is used to compute the intersection");
cls_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.def("ChangePoint", (IntSurf_PntOn2S & (BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::*)()) &BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox::ChangePoint, "return the intersection point which is enable for changing.");

// CLASS: BREPAPPROX_THEMULTILINETOOLOFAPPROX
py::class_<BRepApprox_TheMultiLineToolOfApprox> cls_BRepApprox_TheMultiLineToolOfApprox(mod, "BRepApprox_TheMultiLineToolOfApprox", "None");

// Methods
// cls_BRepApprox_TheMultiLineToolOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_TheMultiLineToolOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_TheMultiLineToolOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_TheMultiLineToolOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_TheMultiLineToolOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_TheMultiLineToolOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_TheMultiLineToolOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_TheMultiLineToolOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_TheMultiLineToolOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_TheMultiLineToolOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_TheMultiLineToolOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_TheMultiLineToolOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("FirstPoint_", (Standard_Integer (*)(const BRepApprox_TheMultiLineOfApprox &)) &BRepApprox_TheMultiLineToolOfApprox::FirstPoint, "Returns the number of multipoints of the TheMultiLine.", py::arg("ML"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("LastPoint_", (Standard_Integer (*)(const BRepApprox_TheMultiLineOfApprox &)) &BRepApprox_TheMultiLineToolOfApprox::LastPoint, "Returns the number of multipoints of the TheMultiLine.", py::arg("ML"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("NbP2d_", (Standard_Integer (*)(const BRepApprox_TheMultiLineOfApprox &)) &BRepApprox_TheMultiLineToolOfApprox::NbP2d, "Returns the number of 2d points of a TheMultiLine.", py::arg("ML"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("NbP3d_", (Standard_Integer (*)(const BRepApprox_TheMultiLineOfApprox &)) &BRepApprox_TheMultiLineToolOfApprox::NbP3d, "Returns the number of 3d points of a TheMultiLine.", py::arg("ML"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("Value_", (void (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, TColgp_Array1OfPnt &)) &BRepApprox_TheMultiLineToolOfApprox::Value, "returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabPt"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("Value_", (void (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, TColgp_Array1OfPnt2d &)) &BRepApprox_TheMultiLineToolOfApprox::Value, "returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabPt2d"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("Value_", (void (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, TColgp_Array1OfPnt &, TColgp_Array1OfPnt2d &)) &BRepApprox_TheMultiLineToolOfApprox::Value, "returns the 3d and 2d points of the multipoint <MPointIndex>.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabPt"), py::arg("tabPt2d"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("Tangency_", (Standard_Boolean (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, TColgp_Array1OfVec &)) &BRepApprox_TheMultiLineToolOfApprox::Tangency, "returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("Tangency_", (Standard_Boolean (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, TColgp_Array1OfVec2d &)) &BRepApprox_TheMultiLineToolOfApprox::Tangency, "returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV2d"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("Tangency_", (Standard_Boolean (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, TColgp_Array1OfVec &, TColgp_Array1OfVec2d &)) &BRepApprox_TheMultiLineToolOfApprox::Tangency, "returns the 3d and 2d points of the multipoint <MPointIndex>.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV"), py::arg("tabV2d"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("Curvature_", (Standard_Boolean (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, TColgp_Array1OfVec &)) &BRepApprox_TheMultiLineToolOfApprox::Curvature, "returns the 3d curvature of the multipoint <MPointIndex> when only 3d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("Curvature_", (Standard_Boolean (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, TColgp_Array1OfVec2d &)) &BRepApprox_TheMultiLineToolOfApprox::Curvature, "returns the 2d curvature points of the multipoint <MPointIndex> only when 2d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV2d"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("Curvature_", (Standard_Boolean (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, TColgp_Array1OfVec &, TColgp_Array1OfVec2d &)) &BRepApprox_TheMultiLineToolOfApprox::Curvature, "returns the 3d and 2d curvature of the multipoint <MPointIndex>.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV"), py::arg("tabV2d"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("MakeMLBetween_", (BRepApprox_TheMultiLineOfApprox (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Integer)) &BRepApprox_TheMultiLineToolOfApprox::MakeMLBetween, "Is called if WhatStatus returned 'PointsAdded'.", py::arg("ML"), py::arg("I1"), py::arg("I2"), py::arg("NbPMin"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("MakeMLOneMorePoint_", (Standard_Boolean (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer, const Standard_Integer, BRepApprox_TheMultiLineOfApprox &)) &BRepApprox_TheMultiLineToolOfApprox::MakeMLOneMorePoint, "Is called when the Bezier curve contains a loop", py::arg("ML"), py::arg("I1"), py::arg("I2"), py::arg("indbad"), py::arg("OtherLine"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("WhatStatus_", (Approx_Status (*)(const BRepApprox_TheMultiLineOfApprox &, const Standard_Integer, const Standard_Integer)) &BRepApprox_TheMultiLineToolOfApprox::WhatStatus, "None", py::arg("ML"), py::arg("I1"), py::arg("I2"));
cls_BRepApprox_TheMultiLineToolOfApprox.def_static("Dump_", (void (*)(const BRepApprox_TheMultiLineOfApprox &)) &BRepApprox_TheMultiLineToolOfApprox::Dump, "Dump of the current multi-line.", py::arg("ML"));

// CLASS: BREPAPPROX_THEPRMPRMSVSURFACESOFAPPROX
py::class_<BRepApprox_ThePrmPrmSvSurfacesOfApprox, ApproxInt_SvSurfaces> cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox(mod, "BRepApprox_ThePrmPrmSvSurfacesOfApprox", "None");

// Constructors
cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def(py::init<const BRepAdaptor_Surface &, const BRepAdaptor_Surface &>(), py::arg("Surf1"), py::arg("Surf2"));

// Methods
// cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def_static("operator new_", (void * (*)(size_t)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::operator new, "None", py::arg("theSize"));
// cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def_static("operator delete_", (void (*)(void *)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::operator delete, "None", py::arg("theAddress"));
// cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def_static("operator new[]_", (void * (*)(size_t)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::operator new[], "None", py::arg("theSize"));
// cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def_static("operator delete[]_", (void (*)(void *)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::operator delete[], "None", py::arg("theAddress"));
// cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def_static("operator new_", (void * (*)(size_t, void *)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def_static("operator delete_", (void (*)(void *, void *)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def("Compute", [](BRepApprox_ThePrmPrmSvSurfacesOfApprox &self, Standard_Real & u1, Standard_Real & v1, Standard_Real & u2, Standard_Real & v2, gp_Pnt & Pt, gp_Vec & Tg, gp_Vec2d & Tguv1, gp_Vec2d & Tguv2){ Standard_Boolean rv = self.Compute(u1, v1, u2, v2, Pt, Tg, Tguv1, Tguv2); return std::tuple<Standard_Boolean, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &>(rv, u1, v1, u2, v2); }, "returns True if Tg,Tguv1 Tguv2 can be computed.", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Pt"), py::arg("Tg"), py::arg("Tguv1"), py::arg("Tguv2"));
cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def("Pnt", (void (BRepApprox_ThePrmPrmSvSurfacesOfApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Pnt &)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::Pnt, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("P"));
cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def("SeekPoint", (Standard_Boolean (BRepApprox_ThePrmPrmSvSurfacesOfApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, IntSurf_PntOn2S &)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::SeekPoint, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Point"));
cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def("Tangency", (Standard_Boolean (BRepApprox_ThePrmPrmSvSurfacesOfApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec &)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::Tangency, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));
cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def("TangencyOnSurf1", (Standard_Boolean (BRepApprox_ThePrmPrmSvSurfacesOfApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec2d &)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::TangencyOnSurf1, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));
cls_BRepApprox_ThePrmPrmSvSurfacesOfApprox.def("TangencyOnSurf2", (Standard_Boolean (BRepApprox_ThePrmPrmSvSurfacesOfApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec2d &)) &BRepApprox_ThePrmPrmSvSurfacesOfApprox::TangencyOnSurf2, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));


}
